generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AggregationWindow {
  windowStart DateTime @id @map("window_start")
  windowEnd   DateTime @map("window_end")
  status      String
  attempt     Int      @default(0)
  lastError   String?  @map("last_error")
  updatedAt   DateTime @default(now()) @map("updated_at")

  combatSegments CombatSegment[]

  @@map("aggregation_windows")
}

model CombatSegment {
  segmentId        String   @id @map("segment_id") @db.Uuid
  windowStart      DateTime @map("window_start")
  content          String
  startTime        DateTime @map("start_time")
  endTime          DateTime? @map("end_time")
  ordinal          Int
  status           String
  durationMs       Int?     @map("duration_ms")
  presenceResolved Boolean  @default(false) @map("presence_resolved")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @default(now()) @map("updated_at")

  aggregationWindow AggregationWindow @relation(fields: [windowStart], references: [windowStart], onDelete: Cascade)
  participants       SegmentParticipant[]
  playerStats        SegmentPlayerStats[]
  rosterPresence     SegmentRosterPresence[]
  issues             SegmentIssue[]

  @@index([windowStart], map: "idx_combat_segments_window_start")
  @@map("combat_segments")
}

model SegmentParticipant {
  segmentId  String   @map("segment_id") @db.Uuid
  playerName String   @map("player_name")
  jobCode    String?  @map("job_code")
  role       String?
  source     String?
  createdAt  DateTime @default(now()) @map("created_at")

  segment CombatSegment @relation(fields: [segmentId], references: [segmentId], onDelete: Cascade)

  @@id([segmentId, playerName])
  @@index([playerName], map: "idx_segment_participants_name")
  @@map("segment_participants")
}

model SegmentPlayerStats {
  segmentId    String   @map("segment_id") @db.Uuid
  playerName   String   @map("player_name")
  totalDamage  BigInt   @map("total_damage") @db.BigInt
  dps          Decimal  @db.Decimal(12, 2)
  hits         Int
  criticalHits Int      @map("critical_hits")
  directHits   Int      @map("direct_hits")
  jobCode      String?  @map("job_code")
  role         String?

  segment CombatSegment @relation(fields: [segmentId], references: [segmentId], onDelete: Cascade)

  @@id([segmentId, playerName])
  @@index([segmentId, dps], map: "idx_segment_player_stats_dps")
  @@map("segment_player_stats")
}

model SegmentRosterPresence {
  segmentId    String   @map("segment_id") @db.Uuid
  rosterId     String   @map("roster_id") @db.Uuid
  playerName   String   @map("player_name")
  matchedName  String?  @map("matched_name")
  matchScore   Decimal? @map("match_score") @db.Decimal(5, 2)
  participated Boolean
  updatedAt    DateTime @default(now()) @map("updated_at")

  segment CombatSegment @relation(fields: [segmentId], references: [segmentId], onDelete: Cascade)

  @@id([segmentId, rosterId])
  @@index([rosterId], map: "idx_segment_roster_presence_roster")
  @@map("segment_roster_presence")
}

model SegmentIssue {
  segmentId String @map("segment_id") @db.Uuid
  issueType String @map("issue_type")
  detail    String?

  segment CombatSegment @relation(fields: [segmentId], references: [segmentId], onDelete: Cascade)

  @@id([segmentId, issueType])
  @@map("segment_issues")
}

model Roster {
  guildId       String  @map("guild_id")
  name          String
  jobCode       String? @map("job_code")
  emoji         String?
  discordUserId String? @map("discord_user_id")
  createdAt     DateTime? @default(now()) @map("created_at")
  updatedAt     DateTime? @default(now()) @map("updated_at")

  @@id([guildId, name])
  @@index([guildId], map: "idx_roster_guild")
  @@map("roster")
}
